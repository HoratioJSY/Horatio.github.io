<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!--Description-->
    
        <meta name="description" content="在本文中，我们将从原论文出发，借助 Goodfellow 在 NIPS 2016 的演讲和台大李弘毅的解释，而完成原 GAN 的推导与证明。本文主要分四部分，第一部分是描述 GAN 的直观概念，第二部分描述概念与优化的形式化表达，第三部分将对 GAN 进行详细的理论推导与分析，最后我们将基于 Ker">
    

    <!--Author-->
    
        <meta name="author" content="Horatio">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="生成对抗网络"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Hello Herbst"/>

    <!--Page Cover-->
    
        <meta property="og:image" content=""/>
    

    <!-- Title -->
    
    <title>生成对抗网络 - Hello Herbst</title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/sass/main.css">

    <!--[if lt IE 8]>
        <script src="/js/ie/html5shiv.js"></script>
    <![endif]-->

    <!--[if lt IE 8]>
        <link rel="stylesheet" href="/sass/ie8.css">
    <![endif]-->

    <!--[if lt IE 9]>
        <link rel="stylesheet" href="/sass/ie9.css">
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


<link rel="shortcut icon" href="http://p598yuf6e.bkt.clouddn.com/favicon.ico" type="image/x-icon"/>
<link rel="icon" href="http://p598yuf6e.bkt.clouddn.com/favicon.ico" type="image/x-icon"/>
<link rel="apple-touch-icon" href="http://p598yuf6e.bkt.clouddn.com/favicon.ico"><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body>

    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="wrapper">

        <!-- Menu -->
        <!-- Header -->
<header id="header">
    <div class="inner">

        <!-- Logo -->
        <a href="/" class="logo">
            <span class="symbol"><img src="http://p598yuf6e.bkt.clouddn.com/BrainIcon.png" alt="" /></span><span class="title">Hello Herbst</span>
        </a>

        <!-- Nav -->
        <nav>
            <ul>
                <li><a href="#menu">Menu</a></li>
            </ul>
        </nav>

    </div>
</header>

<!-- Menu -->
<nav id="menu">
    <h2>Menu</h2>
    <ul>
        
            <li>
                <a href="/">Me</a>
            </li>
        
            <li>
                <a href="/">Photographer</a>
            </li>
        
            <li>
                <a href="/">University life</a>
            </li>
        
            <li>
                <a href="/archives">Archives</a>
            </li>
        
            <li>
                <a href="/">About</a>
            </li>
        
    </ul>
</nav>


        <div id="main">
            <div class="inner">

                <!-- Main Content -->
                

    <h1>生成对抗网络</h1>



<!-- Gallery -->


<!-- Content -->
<p>在本文中，我们将从原论文出发，借助 Goodfellow 在 NIPS 2016 的演讲和台大李弘毅的解释，而完成原 GAN 的推导与证明。本文主要分四部分，第一部分是描述 GAN 的直观概念，第二部分描述概念与优化的形式化表达，第三部分将对 GAN 进行详细的理论推导与分析，最后我们将基于 Keras 和 TensorFlow 实现前面的理论分析。</p>
<h3 id="生成对抗网络基本概念"><a href="#生成对抗网络基本概念" class="headerlink" title="生成对抗网络基本概念"></a>生成对抗网络基本概念</h3><p>要理解生成对抗模型（GAN），首先要了解生成对抗模型可以拆分为两个模块：一个是判别模型，另一个是生成模型。简单来说就是：两个人比赛，看是 A 的矛厉害，还是 B 的盾厉害。比如，我们有一些真实数据，同时也有一把随机生成的假数据。A 拼命地把随手拿过来的假数据模仿成真实数据，并揉进真实数据里。B 则拼命地想把真实数据和假数据区分开。</p>
<p>这里，A 就是一个生成模型，类似于造假币的，一个劲地学习如何骗过 B。而 B 则是一个判别模型，类似于稽查警察，一个劲地学习如何分辨出 A 的造假技巧。</p>
<p>如此这般，随着 B 的鉴别技巧的越来越厉害，A 的造假技巧也是越来越纯熟，而一个一流的假币制造者就是我们所需要的。虽然 GAN 背后的思想十分直观与朴素，但我们需要更进一步了解该理论背后的证明与推导。</p>
<p>总地来说，Goodfellow 等人提出来的 GAN 是通过对抗过程估计生成模型的新框架。在这种框架下，我们需要同时训练两个模型，即一个能捕获数据分布的生成模型 G 和一个能估计数据来源于真实样本概率的判别模型 D。生成器 G 的训练过程是最大化判别器犯错误的概率，即判别器误以为数据是真实样本而不是生成器生成的假样本。因此，这一框架就对应于两个参与者的极小极大博弈（minimax game）。在所有可能的函数 G 和 D 中，我们可以求出唯一均衡解，即 G 可以生成与训练样本相同的分布，而 D 判断的概率处处为 1/2，这一过程的推导与证明将在后文详细解释。</p>
<p>当模型都为多层感知机时，对抗性建模框架可以最直接地应用。为了学习到生成器在数据 x 上的分布 P_g，我们先定义一个先验的输入噪声变量 P_z(z)，然后根据 G(z;θ_g) 将其映射到数据空间中，其中 G 为多层感知机所表征的可微函数。我们同样需要定义第二个多层感知机 D(s;θ_d)，它的输出为单个标量。D(x) 表示 x 来源于真实数据而不是 P_g 的概率。我们训练 D 以最大化正确分配真实样本和生成样本的概率，因此我们就可以通过最小化 log(1-D(G(z))) 而同时训练 G。也就是说判别器 D 和生成器对价值函数 V(G,D) 进行了极小极大化博弈：</p>
<p>$\min _ { G } \max _ { D } V ( D ,G ) = \mathbb { E } _ { x \sim p _ { \operatorname{data} } ( x ) } ( \log D ( x ) ] + \mathbb { E } _ { z \sim p _ { z } ( z ) } [ \log ( 1- D ( G ( z ) ) ) ]$</p>
<p>我们后一部分会对对抗网络进行理论上的分析，该理论分析本质上可以表明如果 G 和 D 的模型复杂度足够（即在非参数限制下），那么对抗网络就能生成数据分布。此外，Goodfellow 等人在论文中使用如下案例为我们简要介绍了基本概念。</p>
<p><img src="http://p598yuf6e.bkt.clouddn.com/gan1.jpg" style="zoom:25%"></p>
<p>如上图所示，生成对抗网络会训练并更新判别分布（即 D，蓝色的虚线），更新判别器后就能将数据真实分布（黑点组成的线）从生成分布 P_g(G)（绿色实线）中判别出来。下方的水平线代表采样域 Z，其中等距线表示 Z 中的样本为均匀分布，上方的水平线代表真实数据 X 中的一部分。向上的箭头表示映射 x=G(z) 如何对噪声样本（均匀采样）施加一个不均匀的分布 P_g。（a）考虑在收敛点附近的对抗训练：P_g 和 P_data 已经十分相似，D 是一个局部准确的分类器。（b）在算法内部循环中训练 D 以从数据中判别出真实样本，该循环最终会收敛到 D（x）=P_data（x）/（P_data（x）+P_g（x））。（c）随后固定判别器并训练生成器，在更新 G 之后，D 的梯度会引导 G（z）流向更可能被 D 分类为真实数据的方向。（d）经过若干次训练后，如果 G 和 D 有足够的复杂度，那么它们就会到达一个均衡点。这个时候 P_g=P_data，即生成器的概率密度函数等于真实数据的概率密度函数，也即生成的数据和真实数据是一样的。在均衡点上 D 和 G 都不能得到进一步提升，并且判别器无法判断数据到底是来自真实样本还是伪造的数据，即 D（x）= 1/2。</p>
<p>上面是比较精简地介绍了生成对抗网络的基本概念，下一节将会把这些概念形式化，并描述优化的大致过程。</p>
<h3 id="概念与过程的形式化"><a href="#概念与过程的形式化" class="headerlink" title="概念与过程的形式化"></a>概念与过程的形式化</h3><h4 id="理论完美的生成器"><a href="#理论完美的生成器" class="headerlink" title="理论完美的生成器"></a>理论完美的生成器</h4><p>该算法的目标是令生成器生成与真实数据几乎没有区别的样本，即一个造假一流的 A，就是我们想要的生成模型。数学上，即将随机变量生成为某一种概率分布，也可以说概率密度函数为相等的：P_G(x)=P_data(x)。这正是数学上证明生成器高效性的策略：即定义一个最优化问题，其中最优生成器 G 满足 P_G(x)=P_data(x)。如果我们知道求解的 G 最后会满足该关系，那么我们就可以合理地期望神经网络通过典型的 SGD 训练就能得到最优的 G。</p>
<h4 id="最优化问题"><a href="#最优化问题" class="headerlink" title="最优化问题"></a>最优化问题</h4><p>正如最开始我们了解的警察与造假者案例，定义最优化问题的方法就可以由以下两部分组成。首先我们需要定义一个判别器 D 以判别样本是不是从 P_data(x) 分布中取出来的，因此有：</p>
<p>$E _ { x \sim p _ { data } } ( x ) \log ( D ( x ) )$</p>
<p>其中 E 指代取期望。这一项是根据「正类」（即辨别出 x 属于真实数据 data）的对数损失函数而构建的。最大化这一项相当于令判别器 D 在 x 服从于 data 的概率密度时能准确地预测 D(x)=1，即：</p>
<p>$ D ( x ) = 1\text{ when } x \sim p _ { d a t a } ( x ) $</p>
<p>另外一项是企图欺骗判别器的生成器 G。该项根据「负类」的对数损失函数而构建，即：</p>
<p>$ E _ { z \sim p _ { z } ( z ) } \log ( 1- D ( G ( z ) ) ) $</p>
<p>因为 x&lt;1 的对数为负，那么如果最大化该项的值，则需要令均值 D(G(z))≈0，因此 G 并没有欺骗 D。为了结合这两个概念，判别器的目标为最大化：</p>
<p>$E_{ x \sim p _ { d a t a } ( x )} \log ( D ( x ) ) + E _ { z \sim p _ { z }  ( z ) }\log ( 1- D ( G ( z ) ) ) $</p>
<p>给定生成器 G，其代表了判别器 D 正确地识别了真实和伪造数据点。给定一个生成器 G，上式所得出来的最优判别器可以表示为 $D_G^<em>$（下文用 D_G</em>表示）。定义价值函数为：</p>
<p>$ V ( G ,D ) : = E _ { x \sim p _ { d a t a } ( x ) } \log ( D ( x ) ) + E _ { z \sim p _ { z } ( z ) } \log ( 1- D ( G ( z ) ) ) $</p>
<p>然后我们可以将最优化问题表述为：</p>
<p>$ D _ {  G } ^\star = \operatorname{arg} \max _ { D } V ( G ,D ) D _ { G  } ^\star = \operatorname{arg} \max _ { D } V ( G ,D ) $</p>
<p>现在 G 的目标已经相反了，当 D=D_G* 时，最优的 G 为最小化前面的等式。在论文中，作者更喜欢求解最优化价值函的 G 和 D 以求解极小极大博弈：</p>
<p>$ \min _ { G } \max _ { D } V ( D ,G ) = \mathbb { E } _ { x \sim p _ { \text{data} } ( x ) } [ \log D ( x ) ] + \mathbb { E } _ { z \sim p _ { z } } ( z ) [ \log ( 1- D ( G ( z ) ) ) ] $</p>
<p>对于 D 而言要尽量使公式最大化（识别能力强），而对于 G 又想使之最小（生成的数据接近实际数据）。整个训练是一个迭代过程。其实极小极大化博弈可以分开理解，即在给定 G 的情况下先最大化 V(D,G) 而取 D，然后固定 D，并最小化 V(D,G) 而得到 G。其中，给定 G，最大化 V(D,G) 评估了 P_G 和 P_data 之间的差异或距离。</p>
<p>最后，我们可以将最优化问题表达为：</p>
<p>$ G ^\star= \operatorname{arg} \min _ { G } V \left( G ,D _ { G } ^\star \right) $</p>
<p>上文给出了 GAN 概念和优化过程的形式化表达。通过这些表达，我们可以理解整个生成对抗网络的基本过程与优化方法。当然，有了这些概念我们完全可以直接在 GitHub 上找一段 GAN 代码稍加修改并很好地运行它。但如果我们希望更加透彻地理解 GAN，更加全面地理解实现代码，那么我们还需要知道很多推导过程。比如什么时候 D 能令价值函数 V(D,G) 取最大值、G 能令 V(D,G) 取最小值，而 D 和 G 该用什么样的神经网络（或函数），它们的损失函数又需要用什么等等。总之，还有很多理论细节与推导过程需要我们进一步挖掘。</p>
<h3 id="理论推导"><a href="#理论推导" class="headerlink" title="理论推导"></a>理论推导</h3><p>在原 GAN 论文中，度量生成分布与真实分布之间差异或距离的方法是 JS 散度，而 JS 散度是我们在推导训练过程中使用 KL 散度所构建出来的。所以这一部分将从理论基础出发再进一步推导最优判别器和生成器所需要满足的条件，最后我们将利用推导结果在数学上重述训练过程。这一部分为我们下一部分理解具体实现提供了强大的理论支持。</p>
<h4 id="KL-散度"><a href="#KL-散度" class="headerlink" title="KL 散度"></a>KL 散度</h4><p>在信息论中，我们可以使用香农熵（Shannon entropy）来对整个概率分布中的不确定性总量进行量化：</p>
<p>$ H ( x ) = \mathbb { E } _ { x \sim P } [ I ( x ) ] = - \mathbb { E } _ { x \sim P } [ \log P ( x ) ] $</p>
<p>如果我们对于同一个随机变量 x 有两个单独的概率分布 P(x) 和 Q(x)，我们可 以使用 KL 散度（Kullback-Leibler divergence）来衡量这两个分布的差异：</p>
<p>$ D _ { K L } ( P | Q ) = \mathbb { E } _ { x \sim P } \left[ \log \frac { P ( x ) } { Q ( x ) } \right] = \mathbb { E } _ { x \sim P } [ \log P ( x ) - \log Q ( x ) ] $</p>
<p>在离散型变量的情况下，KL 散度衡量的是，当我们使用一种被设计成能够使 得概率分布 Q 产生的消息的长度最小的编码，发送包含由概率分布 P 产生的符号 的消息时，所需要的额外信息量。</p>
<p>KL 散度有很多有用的性质，最重要的是它是非负的。KL 散度为 0 当且仅当 P 和 Q 在离散型变量的情况下是相同的分布，或者在连续型变量的情况下是 『几乎 处处』 相同的。因为 KL 散度是非负的并且衡量的是两个分布之间的差异，它经常 被用作分布之间的某种距离。然而，它并不是真的距离因为它不是对称的：对于某 些 P 和 Q，D_KL(P||Q) 不等于 D_KL(Q||P)。这种非对称性意味着选择 D_KL(P||Q) 还是 D_KL(Q||P) 影响很大。</p>
<p>在李弘毅的讲解中，KL 散度可以从极大似然估计中推导而出。若给定一个样本数据的分布 P_data(x) 和生成的数据分布 P_G(x;θ)，那么 GAN 希望能找到一组参数θ使分布 P_g(x;θ) 和 P_data(x) 之间的距离最短，也就是找到一组生成器参数而使得生成器能生成十分逼真的图片。</p>
<p>现在我们可以从训练集抽取一组真实图片来训练 P_G(x;θ) 分布中的参数θ使其能逼近于真实分布。因此，现在从 P_data(x) 中抽取 m 个真实样本 {𝑥^1,𝑥^2,…,𝑥^𝑚}，其中符号「^」代表上标，即 x 中的第 i 个样本。对于每一个真实样本，我们可以计算 P_G(x^i;θ)，即在由θ确定的生成分布中，x^i 样本所出现的概率。因此，我们就可以构建似然函数：</p>
<p>$ L = \prod _ { i = 1} ^ { m } P _ { G } \left( x ^ { i } ; \theta \right) $</p>
<p>其中「∏」代表累乘、P_G(x^i;θ) 代表第 i 个样本在生成分布出现的概率。从该似然函数可知，我们抽取的 m 个真实样本在 P_G(x;θ) 分布中全部出现的概率值可以表达为 L。又因为若 P_G(x;θ) 分布和 P_data(x) 分布相似，那么真实数据很可能就会出现在 P_G(x;θ) 分布中，因此 m 个样本都出现在 P_G(x;θ) 分布中的概率就会十分大。</p>
<p>下面我们就可以最大化似然函数 L 而求得离真实分布最近的生成分布（即最优的参数θ）：</p>
<p><img src="http://p598yuf6e.bkt.clouddn.com/gan2.png" style="zoom:40%"></p>
<p>在上面的推导中，我们希望最大化似然函数 L。若对似然函数取对数，那么累乘∏就能转化为累加∑，并且这一过程并不会改变最优化的结果。因此我们可以将极大似然估计化为求令 log[P_G(x;θ)] 期望最大化的θ，而期望 E[logP_G(x;θ)] 可以展开为在 x 上的积分形式：∫P_data(x)logP_G(x;θ)dx。又因为该最优化过程是针对θ的，所以我们添加一项不含θ的积分并不影响最优化效果，即可添加 -∫P_data(x)logP_data(x)dx。添加该积分后，我们可以合并这两个积分并构建类似 KL 散度的形式。该过程如下：</p>
<p>$ \int _ { x } P _ { \operatorname{data} } ( x ) \log P _ { G } ( x ,\theta ) - P _ { d a t a } ( x ) \log P _ { d a t a } ( x ) d x = \int _ { x } P _ { d a t a } ( x ) \log \frac { P _ { G } ( x ,\theta ) } { P _ { d a t a } ( x ) } $</p>
<p>这一个积分就是 KL 散度的积分形式，因此，如果我们需要求令生成分布 P_G(x;θ) 尽可能靠近真实分布 P_data(x) 的参数θ，那么我们只需要求令 KL 散度最小的参数θ。若取得最优参数θ，那么生成器生成的图像将显得非常真实。</p>
<h4 id="推导存在的问题"><a href="#推导存在的问题" class="headerlink" title="推导存在的问题"></a>推导存在的问题</h4><p>下面，我们必须证明该最优化问题有唯一解 G*，并且该唯一解满足 P_G=P_data。不过在开始推导最优判别器和最优生成器之前，我们需要了解 Scott Rome 对原论文推导的观点，他认为原论文忽略了可逆条件，因此最优解的推导不够完美。</p>
<p>在 GAN 原论文中，有一个思想和其它很多方法都不同，即生成器 G 不需要满足可逆条件。Scott Rome 认为这一点非常重要，因为实践中 G 就是不可逆的。而很多证明笔记都忽略了这一点，他们在证明时错误地使用了积分换元公式，而积分换元却又恰好基于 G 的可逆条件。Scott 认为证明只能基于以下等式的成立性：</p>
<p>$ E _ { z \sim p _ { z } ( z ) } \log ( 1- D ( G ( z ) ) ) = E _ { x \sim p _ { G } ( x ) } \log ( 1- D ( x ) ) $</p>
<p>该等式来源于测度论中的 Radon-Nikodym 定理，它展示在原论文的命题 1 中，并且表达为以下等式：</p>
<p>$ \left.\begin{array} { l } { \int _ { x } p _ { d a t a } ( x ) \log D ( x ) d x + \int _ { z } p ( z ) \log ( 1- D ( G ( z ) ) ) dz } \ { = \int _ { x } p _ { d a t a } ( x ) \log D ( x ) + p _ { G } ( x ) \log ( 1- D ( x ) ) \text{d} x } \end{array} \right. $</p>
<p>我们看到该讲义使用了积分换元公式，但进行积分换元就必须计算 G^(-1)，而 G 的逆却并没有假定为存在。并且在神经网络的实践中，它也并不存在。可能这个方法在机器学习和统计学文献中太常见了，因此我们忽略了它。</p>
<h4 id="最优判别器"><a href="#最优判别器" class="headerlink" title="最优判别器"></a>最优判别器</h4><p>在极小极大博弈的第一步中，给定生成器 G，最大化 V(D,G) 而得出最优判别器 D。其中，最大化 V(D,G) 评估了 P_G 和 P_data 之间的差异或距离。因为在原论文中价值函数可写为在 x 上的积分，即将数学期望展开为积分形式：</p>
<p>$ V ( G ,D ) = \int _ { x } p _ { data} ( x ) \log ( D ( x ) ) + p _ { g } ( x ) \log ( 1- D ( x ) ) d x $</p>
<p>其实求积分的最大值可以转化为求被积函数的最大值。而求被积函数的最大值是为了求得最优判别器 D，因此不涉及判别器的项都可以看作为常数项。如下所示，P_data(x) 和 P_G(x) 都为标量，因此被积函数可表示为 a<em>D(x)+b</em>log(1-D(x))。</p>
<p><img src="http://p598yuf6e.bkt.clouddn.com/gan3.png" style="zoom:45%"></p>
<p>若令判别器 D(x) 等于 y，那么被积函数可以写为：</p>
<p>$ f ( y ) = a \log y + b \log ( 1- y ) ​$</p>
<p>为了找到最优的极值点，如果 a+b≠0，我们可以用以下一阶导求解：</p>
<p>$ f ^ { \prime } ( y ) = 0\Rightarrow \frac { a } { y } - \frac { b } { 1- y } = 0\Rightarrow y = \frac { a } { a + b } $</p>
<p>如果我们继续求表达式 f(y) 在驻点的二阶导：</p>
<p>$ f ^ { \prime \prime } \left( \frac { a } { a + b } \right) = - \frac { a } { \left( \frac { a } { a + b } \right) ^ { 2} } - \frac { b } { 1- \left( \frac { a } { a + b } \right) ^ { 2} } &lt; 0 $</p>
<p>其中 a,b∈(0,1)。因为一阶导等于零、二阶导小于零，所以我们知道 a/(a+b) 为极大值。若将 a=P_data(x)、b=P_G(x) 代入该极值，那么最优判别器 D(x)=P_data(x)/(P_data(x)+P_G(x))。</p>
<p>最后我们可以将价值函数表达式写为：</p>
<p>$ \left.\begin{aligned} V ( G ,D ) &amp; = \int _ { x } p _ { d a t a } ( x ) \log D ( x ) + p _ { G } ( x ) \log ( 1- D ( x ) ) d x  \leq \int _ { x } \max_y p _ { d a t a } ( x ) \log y + p _ { G } ( x ) \log ( 1- y ) \text{d} x \end{aligned} \right. $</p>
<p>如果我们令 D(x)=P_data/(P_data+p_G)，那么我们就可以令价值函数 V(G,D) 取极大值。因为 f(y) 在定义域内有唯一的极大值，最优 D 也是唯一的，并且没有其它的 D 能实现极大值。</p>
<p>其实该最优的 D 在实践中并不是可计算的，但在数学上十分重要。我们并不知道先验的 P_data(x)，所以我们在训练中永远不会用到它。另一方面，它的存在令我们可以证明最优的 G 是存在的，并且在训练中我们只需要逼近 D。</p>
<h4 id="最优生成器"><a href="#最优生成器" class="headerlink" title="最优生成器"></a>最优生成器</h4><p>当然 GAN 过程的目标是令 P_G=P_data。这对最优的 D 意味着什么呢？我们可以将这一等式代入 D_G*的表达式中：</p>
<p>$ D _ { G } ^ { * } = \frac { p _ { d a t a } } { p _ { d a t a } + p _ { G } } = \frac { 1} { 2} $</p>
<p>这意味着判别器已经完全困惑了，它完全分辨不出 P_data 和 P_G 的区别，即判断样本来自 P_data 和 P_G 的概率都为 1/2。基于这一观点，GAN 作者证明了 G 就是极小极大博弈的解。该定理如下：</p>
<p>「当且仅当 P_G=P_data，训练标准 C(G)=maxV(G,D) 的全局最小点可以达到。」</p>
<p>以上定理即极大极小博弈的第二步，求令 V(G,D<em>) 最小的生成器 G（其中 G</em>代表最优的判别器）。之所以当 P_G(x)=P_data(x) 可以令价值函数最小化，是因为这时候两个分布的 JS 散度 [JSD(P_data(x) || P_G(x))] 等于零，这一过程的详细解释如下。</p>
<p>原论文中的这一定理是「当且仅当」声明，所以我们需要从两个方向证明。首先我们先从反向逼近并证明 C(G) 的取值，然后再利用由反向获得的新知识从正向证明。设 P_G=P_data（反向指预先知道最优条件并做推导），我们可以反向推出：</p>
<p>$ V \left( G ,D _ { G } ^ { * } \right) = \int _ { x } p _ { d a t a } ( x ) \log \frac { 1} { 2} + p _ { G } ( x ) \log \left( 1- \frac { 1} { 2} \right) d x $</p>
<p>$ V \left( G ,D _ { G } ^ { * } \right) = - \log 2\int _ { x } p _ { G } ( x ) \text{d} x - \log 2\int _ { x } p _ { d a t a } ( x ) \text{d} x = - 2\log 2= - \log 4 $</p>
<p>该值是全局最小值的候选，因为它只有在 P_G=P_data 的时候才出现。我们现在需要从正向证明这一个值常常为最小值，也就是同时满足「当」和「仅当」的条件。现在放弃 P_G=P_data 的假设，对任意一个 G，我们可以将上一步求出的最优判别器 D* 代入到 C(G)=maxV(G,D) 中： </p>
<p>$ C ( G ) = \int _ { x } p _ { d a t a } ( x ) \log \left( \frac { p _ { d a t a } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } \right) + p _ { G } ( x ) \log \left( \frac { p _ { G } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } \right) \text{d} x $</p>
<p>因为已知 -log4 为全局最小候选值，所以我们希望构造某个值以使方程式中出现 log2。因此我们可以在每个积分中加上或减去 log2，并乘上概率密度。这是一个十分常见并且不会改变等式的数学证明技巧，因为本质上我们只是在方程加上了 0。</p>
<p>$ \left.\begin{aligned} C ( G ) &amp; = \int _ { x } ( \log 2- \log 2) p _ { d a t a } ( x ) + p _ { d a t a } ( x ) \log ( \frac { p _ { d a t a } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } ) + ( \log 2- \log 2) p _ { G } ( x ) + p _ { G } ( x ) \log ( \frac { p _ { G } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } ) \text{d} x \end{aligned} \right. $</p>
<p>采用该技巧主要是希望能够构建成含 log2 和 JS 散度的形式，上式化简后可以得到以下表达式：</p>
<p>$ \left.\begin{array} { c } { C ( G ) = - \log 2\int _ { x } p _ { G } ( x ) + p _ { d a t a } ( x ) d x } { + \int _ { p } p _ { d a t a } ( x ) \left( \log 2+ \log \left( \frac { p _ { d a t a } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } \right) \right) }{ + p _ { G } ( x ) \left( \log 2+ \log \left( \frac { p _ { G } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } \right) \right) \text{d} x } \end{array} \right. $</p>
<p>因为概率密度的定义，P_G 和 P_data 在它们积分域上的积分等于 1，即：</p>
<p>$ - \log 2\int _ { x } p G ( x ) + p _ { d a t a } ( x ) \text{d} x = - \log 2( 1+ 1) = - 2\log 2= - \log 4 $</p>
<p>此外，根据对数的定义，我们有：</p>
<p>$ \left.\begin{aligned} \log 2+ \log ( \frac { p _ { d a t a } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } ) &amp; = \log ( 2\frac { p _ { d a t a } ( x ) } { p _ { G } ( x ) + p _ { d a t a } ( x ) } ) = \log ( \frac { p _ { d a t a } ( x ) } { ( p _ { G } ( x ) + p _ { d a t a } ( x ) ) / 2} \end{aligned} \right. $</p>
<p>因此代入该等式，我们可以写为：</p>
<p>$ \left.\begin{aligned} C ( G ) &amp; = - \log 4+ \int _ { x } p _ { d a t a } ( x ) \log ( \frac { p _ { d a t a } ( x ) } { ( p _ { G } ( x ) + p _ { d a t a } ( x ) ) / 2} ) d x  + \int _ { x } p _ { G } ( x ) \log ( \frac { p _ { G } ( x ) } { ( p _ { G } ( x ) + p _ { d a t a } ( x ) ) / 2} ) d x \end{aligned} \right. $</p>
<p>现在，如果读者阅读了前文的 KL 散度（Kullback-Leibler divergence），那么我们就会发现每一个积分正好就是它。具体来说：</p>
<p>$ C ( G ) = - \log 4+ K L \left( p _ { d a t a } | \frac { p _ { d a t a } + p _ { G } } { 2} \right) + K L \left( p _ { G } | \frac { p _ { d a t a } + p _ { G } } { 2} \right) $</p>
<p>KL 散度是非负的，所以我们马上就能看出来-log4 为 C(G) 的全局最小值。</p>
<p>如果我们进一步证明只有一个 G 能达到这一个值，因为 P_G=P_data 将会成为令 C(G)=−log4 的唯一点，所以整个证明就能完成了。</p>
<p>从前文可知 KL 散度是非对称的，所以 C(G) 中的 KL(P_data || (P_data+P_G)/2) 左右两项是不能交换的，但如果同时加上另一项 KL(P_G || (P_data+P_G)/2)，它们的和就能变成对称项。这两项 KL 散度的和即可以表示为 JS 散度（Jenson-Shannon divergence）：</p>
<p>$ \left.\begin{array} { r l } { \text{JSD} ( P | Q ) = \frac { 1} { 2} D ( P | M ) + \frac { 1} { 2} D ( Q | M ) } \ { M = \frac { 1} { 2} ( P + Q ) } \end{array} \right. $</p>
<p>假设存在两个分布 P 和 Q，且这两个分布的平均分布 M=(P+Q)/2，那么这两个分布之间的 JS 散度为 P 与 M 之间的 KL 散度加上 Q 与 M 之间的 KL 散度再除以 2。</p>
<p>JS 散度的取值为 0 到 log2。若两个分布完全没有交集，那么 JS 散度取最大值 log2；若两个分布完全一样，那么 JS 散度取最小值 0。</p>
<p>因此 C(G) 可以根据 JS 散度的定义改写为：</p>
<p>$ C ( G ) = - \log 4+ 2\cdot J S D \left( p _ { d a t a } | p _ { G } \right) $</p>
<p>这一散度其实就是 Jenson-Shannon 距离度量的平方。根据它的属性：当 P_G=P_data 时，JSD(P_data||P_G) 为 0。综上所述，生成分布当且仅当等于真实数据分布式时，我们可以取得最优生成器。</p>
<h4 id="收敛"><a href="#收敛" class="headerlink" title="收敛"></a>收敛</h4><p>现在，该论文的主要部分已经得到了证明：即 P_G=P_data 为 maxV(G,D) 的最优点。此外，原论文还有额外的证明白表示：给定足够的训练数据和正确的环境，训练过程将收敛到最优 G，我们并不详细讨论这一块。</p>
<h4 id="重述训练过程"><a href="#重述训练过程" class="headerlink" title="重述训练过程"></a>重述训练过程</h4><p>下面是推导的最后一步，我们会重述整个参数优化过程，并简要介绍实际训练中涉及的各个过程。</p>
<p>1.参数优化过程</p>
<p>若我们需要寻找最优的生成器，那么给定一个判别器 D，我们可以将 maxV(G,D) 看作训练生成器的损失函数 L(G)。既然设定了损失函数，那么我们就能使用 SGD、Adam 等优化算法更新生成器 G 的参数，梯度下降的参数优化过程如下：</p>
<p>$ \theta _ { G } \leftarrow \theta _ { G } - \eta \partial L ( G ) / \partial \theta _ { G } $</p>
<p>其中求 L(G) 对θ_G 的偏导数涉及到求 max{V(G,D)} 的偏导数，这种对 max 函数求微分的方式是存在且可用的。</p>
<p>现在给定一个初始 G_0，我们需要找到令 V(G_0,D) 最大的 D_0*，因此判别器更新的过程也就可以看作损失函数为-V(G,D) 的训练过程。并且由前面的推导可知，V(G,D) 实际上与分布 P_data(x) 和 P_G(x) 之间的 JS 散度只差了一个常数项。因此这样一个循环对抗的过程就能表述为：</p>
<ul>
<li>给定 G_0，最大化 V(G_0,D) 以求得 D_0*，即 max[JSD(P_data(x)||P_G0(x)]；</li>
<li>固定 D_0<em>，计算θ_G1 ← θ_G0 −η(𝜕V(G,D_0</em>) /𝜕θ_G) 以求得更新后的 G_1；</li>
<li>固定 G_1，最大化 V(G_1,D_0<em>) 以求得 D_1</em>，即 max[JSD(P_data(x)||P_G1(x)]；</li>
<li>固定 D_1<em>，计算θ_G2 ← θ_G1 −η(𝜕V(𝐺,𝐷_0</em>) /𝜕θ_G) 以求得更新后的 G_2；</li>
<li>。。。</li>
</ul>
<p>2.实际训练过程</p>
<p>根据前面价值函数 V(G,D) 的定义，我们需要求两个数学期望，即 E[log(D(x))] 和 E[log(1-D(G(z)))]，其中 x 服从真实数据分布，z 服从初始化分布。但在实践中，我们是没有办法利用积分求这两个数学期望的，所以一般我们能从无穷的真实数据和无穷的生成器中做采样以逼近真实的数学期望。</p>
<p>若现在给定生成器 G，并希望计算 maxV(G,D) 以求得判别器 D，那么我们首先需要从 P_data(x) 采样 m 个样本 {𝑥^1,𝑥^2,…,𝑥^𝑚}，从生成器 P_G(x) 采样 m 个样本 ${\tilde{x}^1,\tilde{x}^2, \dots,\tilde{x}^m}$ 。因此最大化价值函数 V(G,D) 就可以使用以下表达式近似替代：</p>
<p>$Maximize\ \ \tilde { V } = \frac { 1} { m } \sum _ { i = 1} ^ { m } \log D \left( x ^ { i } \right) + \frac { 1} { m } \sum _ { i = 1} ^ { m } \log \left( 1- D \left( \tilde { x } ^ { i } \right) \right) $</p>
<p>若我们需要计算上述的极大化过程，可以采用等价形式的训练方法。若我们有一个二元分类器 D（参数为θ_d），当然该分类器可以是深度神经网络，那么极大化过程的输出就为该分类器 D(x)。现在我们从 P_data(x) 抽取样本作为正样本，从 P_G(x) 抽取样本作为负样本，同时将逼近负 V(G,D) 的函数作为损失函数，因此我们就将其表述为一个标准的二元分类器的训练过程：</p>
<p><img src="http://p598yuf6e.bkt.clouddn.com/gan4.png" style="zoom:40%"></p>
<p>在实践中，我们必须使用迭代和数值计算的方法实现极小极大化博弈过程。在训练的内部循环中完整地优化 D 在计算上是不允许的，并且有限的数据集也会导致过拟合。因此我们可以在 k 个优化 D 的步骤和一个优化 G 的步骤间交替进行。那么我们只需慢慢地更新 G，D 就会一直处于最优解的附近，这种策略类似于 SML/PCD 训练的方式。</p>
<p>综上，我们可以描述整个训练过程，对于每一次迭代：</p>
<ul>
<li>从真实数据分布 P_data 抽取 m 个样本</li>
<li>从先验分布 P_prior(z) 抽取 m 个噪声样本</li>
<li>将噪声样本投入 G 而生成数据${\tilde{x}^1,\tilde{x}^2, \dots,\tilde{x}^m},\tilde{x}^1=G(z^i)$ ，通过最大化 V 的近似而更新判别器参数θ_d，即极大化 $ \tilde { V } = \frac { 1} { m } \sum _ { i = 1} ^ { m } \log D \left( x ^ { i } \right) + \frac { 1} { m } \sum _ { i = 1} ^ { m } \log \left( 1- D \left( \tilde { x } ^ { i } \right) \right) $，且判别器参数的更新迭代式为 $ \theta _ { d } \leftrightarrow \theta _ { d } + \eta \nabla \tilde { V } \left( \theta _ { d } \right) $。</li>
</ul>
<p>以上是学习判别器 D 的过程。因为学习 D 的过程是计算 JS 散度的过程，并且我们希望能最大化价值函数，所以该步骤会重复 k 次。</p>
<ul>
<li>从先验分布 P_prior(z) 中抽取另外 m 个噪声样本 {z^1,…,z^m}</li>
<li>通过极小化 V^tilde 而更新生成器参数θ_g，即极大化 $ \tilde { V } = \frac { 1} { m } \sum _ { i = 1} ^ { m } \log \left( 1- D \left( G \left( z ^ { i } \right) \right) \right) $，且生成器参数的更新迭代式为 $ \theta _ { g } \leftrightarrow \theta _ { g } - \eta \nabla \tilde { V } \left( \theta _ { g } \right) $。</li>
</ul>
<p>以上是学习生成器参数的过程，这一过程在一次迭代中只会进行一次，因此可以避免更新太多而令 JS 散度上升。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>我们首先提供的是 GAN 实现代码与注释，随后我们会将以上的理论分析与实现代码相结合并展示在 Jupyter Notebook 中。前面的实现使用的是比较简单的高级 API（Keras），后面补充了使用 TensorFlow 构建 GAN 的代码与注释。</p>
<p>首先使用基于 TensorFlow 后端的 Keras 实现了该生成对抗网络，并且我们在 MNIST 数据集上对模型进行训练并生成了一系列手写字体。这一章节只简要解释部分实现代码，更完整与详细的注释请查看 GitHub 项目地址。</p>
<h4 id="生成模型"><a href="#生成模型" class="headerlink" title="生成模型"></a>生成模型</h4><p>首先需要定义一个生成器 G，该生成器需要将输入的随机噪声变换为图像。以下是定义的生成模型，该模型首先输入有 100 个元素的向量，该向量随机生成于某分布。随后利用两个全连接层接连将该输入向量扩展到 1024 维和 128<em>7</em>7 维，后面就开始将全连接层所产生的一维张量重新塑造成二维张量，即 MNIST 中的灰度图。我们注意到该模型采用的激活函数为 tanh，所以也尝试过将其转换为 relu 函数，但发现生成模型如果转化为 relu 函数，那么它的输出就会成为一片灰色。</p>
<p>由全连接传递的数据会经过几个上采样层和卷积层，我们注意到最后一个卷积层所采用的卷积核为 1，所以经过最后卷积层所生成的图像是一张二维灰度图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#下面搭建生成器的架构，首先导入序贯模型（sequential），即多个网络层的线性堆叠</span></span><br><span class="line">    model = Sequential()</span><br><span class="line">    <span class="comment">#添加一个全连接层，输入为100维向量，输出为1024维</span></span><br><span class="line">    model.add(Dense(input_dim=<span class="number">100</span>, output_dim=<span class="number">1024</span>))</span><br><span class="line">    <span class="comment">#添加一个激活函数tanh</span></span><br><span class="line">    model.add(Activation(<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="comment">#添加一个全连接层，输出为128×7×7维度</span></span><br><span class="line">    model.add(Dense(<span class="number">128</span>*<span class="number">7</span>*<span class="number">7</span>))</span><br><span class="line">    <span class="comment">#添加一个批量归一化层，该层在每个batch上将前一层的激活值重新规范化，即使得其输出数据的均值接近0，其标准差接近1</span></span><br><span class="line">    model.add(BatchNormalization())</span><br><span class="line">    model.add(Activation(<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="comment">#Reshape层用来将输入shape转换为特定的shape，将含有128*7*7个元素的向量转化为7×7×128张量</span></span><br><span class="line">    model.add(Reshape((<span class="number">7</span>, <span class="number">7</span>, <span class="number">128</span>), input_shape=(<span class="number">128</span>*<span class="number">7</span>*<span class="number">7</span>,)))</span><br><span class="line">    <span class="comment">#2维上采样层，即将数据的行和列分别重复2次</span></span><br><span class="line">    model.add(UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">    <span class="comment">#添加一个2维卷积层，卷积核大小为5×5，激活函数为tanh，共64个卷积核，并采用padding以保持图像尺寸不变</span></span><br><span class="line">    model.add(Conv2D(<span class="number">64</span>, (<span class="number">5</span>, <span class="number">5</span>), padding=<span class="string">'same'</span>))</span><br><span class="line">    model.add(Activation(<span class="string">'tanh'</span>))</span><br><span class="line">    model.add(UpSampling2D(size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">    <span class="comment">#卷积核设为1即输出图像的维度</span></span><br><span class="line">    model.add(Conv2D(<span class="number">1</span>, (<span class="number">5</span>, <span class="number">5</span>), padding=<span class="string">'same'</span>))</span><br><span class="line">    model.add(Activation(<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>前面定义的是可生成图像的模型 G(z;θ_g)，而我们在训练生成模型时，需要固定判别模型 D 以极小化价值函数而寻求更好的生成模型，这就意味着我们需要将生成模型与判别模型拼接在一起，并固定 D 的权重以训练 G 的权重。下面就定义了这一过程，我们先添加前面定义的生成模型，再将定义的判别模型拼接在生成模型下方，并且我们将判别模型设置为不可训练。因此，训练这个组合模型才能真正更新生成模型的参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_containing_discriminator</span><span class="params">(g, d)</span>:</span></span><br><span class="line">    <span class="comment">#将前面定义的生成器架构和判别器架构组拼接成一个大的神经网络，用于判别生成的图片</span></span><br><span class="line">    model = Sequential()</span><br><span class="line">    <span class="comment">#先添加生成器架构，再令d不可训练，即固定d</span></span><br><span class="line">    <span class="comment">#因此在给定d的情况下训练生成器，即通过将生成的结果投入到判别器进行辨别而优化生成器</span></span><br><span class="line">    model.add(g)</span><br><span class="line">    d.trainable = <span class="keyword">False</span></span><br><span class="line">    model.add(d)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<h4 id="判别模型"><a href="#判别模型" class="headerlink" title="判别模型"></a>判别模型</h4><p>判别模型相对来说就是比较传统的图像识别模型，前面我们可以按照经典的方法采用几个卷积层与最大池化层，而后再展开为一维张量并采用几个全连接层作为架构。我们尝试了将 tanh 激活函数改为 relu 激活函数，在前两个 epoch 基本上没有什么明显的变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator_model</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#下面搭建判别器架构，同样采用序贯模型</span></span><br><span class="line">    model = Sequential()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#添加2维卷积层，卷积核大小为5×5，激活函数为tanh，输入shape在‘channels_first’模式下为（samples,channels，rows，cols）</span></span><br><span class="line">    <span class="comment">#在‘channels_last’模式下为（samples,rows,cols,channels），输出为64维</span></span><br><span class="line">    model.add(</span><br><span class="line">            Conv2D(<span class="number">64</span>, (<span class="number">5</span>, <span class="number">5</span>),</span><br><span class="line">            padding=<span class="string">'same'</span>,</span><br><span class="line">            input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>))</span><br><span class="line">            )</span><br><span class="line">    model.add(Activation(<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="comment">#为空域信号施加最大值池化，pool_size取（2，2）代表使图片在两个维度上均变为原长的一半</span></span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">    model.add(Conv2D(<span class="number">128</span>, (<span class="number">5</span>, <span class="number">5</span>)))</span><br><span class="line">    model.add(Activation(<span class="string">'tanh'</span>))</span><br><span class="line">    model.add(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line">    <span class="comment">#Flatten层把多维输入一维化，常用在从卷积层到全连接层的过渡</span></span><br><span class="line">    model.add(Flatten())</span><br><span class="line">    model.add(Dense(<span class="number">1024</span>))</span><br><span class="line">    model.add(Activation(<span class="string">'tanh'</span>))</span><br><span class="line">    <span class="comment">#一个结点进行二值分类，并采用sigmoid函数的输出作为概念</span></span><br><span class="line">    model.add(Dense(<span class="number">1</span>))</span><br><span class="line">    model.add(Activation(<span class="string">'sigmoid'</span>))</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<h4 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h4><p>训练这一部分比较长，也值得我们进行详细的探讨。总的来说，以下训练过程可简述为：</p>
<ul>
<li>加载 MNIST 数据</li>
<li>将数据分割为训练与测试集，并赋值给变量</li>
<li>设置训练模型的超参数</li>
<li>编译模型的训练过程</li>
<li>在每一次迭代内，抽取生成图像与真实图像，并打上标注</li>
<li>随后将数据投入到判别模型中，并进行训练与计算损失</li>
<li>固定判别模型，训练生成模型并计算损失，结束这一次迭代</li>
</ul>
<p>以上是下面训练过程的简要介绍，我们将结合上文的理论推导在 GitHub 中展示更详细的分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(BATCH_SIZE)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 国内好像不能直接导入数据集，我们试了几次都不行，后来将数据集下载到本地'~/.keras/datasets/'，也就是当前目录（我的是用户文件夹下）下的.keras文件夹中。</span></span><br><span class="line">    <span class="comment">#下载的地址为：https://s3.amazonaws.com/img-datasets/mnist.npz</span></span><br><span class="line">    (X_train, y_train), (X_test, y_test) = mnist.load_data()</span><br><span class="line">    <span class="comment">#iamge_data_format选择"channels_last"或"channels_first"，该选项指定了Keras将要使用的维度顺序。</span></span><br><span class="line">    <span class="comment">#"channels_first"假定2D数据的维度顺序为(channels, rows, cols)，3D数据的维度顺序为(channels, conv_dim1, conv_dim2, conv_dim3)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#转换字段类型，并将数据导入变量中</span></span><br><span class="line">    X_train = (X_train.astype(np.float32) - <span class="number">127.5</span>)/<span class="number">127.5</span></span><br><span class="line">    X_train = X_train[:, :, :, <span class="keyword">None</span>]</span><br><span class="line">    X_test = X_test[:, :, :, <span class="keyword">None</span>]</span><br><span class="line">    <span class="comment"># X_train = X_train.reshape((X_train.shape, 1) + X_train.shape[1:])</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将定义好的模型架构赋值给特定的变量</span></span><br><span class="line">    d = discriminator_model()</span><br><span class="line">    g = generator_model()</span><br><span class="line">    d_on_g = generator_containing_discriminator(g, d)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#定义生成器模型判别器模型更新所使用的优化算法及超参数</span></span><br><span class="line">    d_optim = SGD(lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>, nesterov=<span class="keyword">True</span>)</span><br><span class="line">    g_optim = SGD(lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>, nesterov=<span class="keyword">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#编译三个神经网络并设置损失函数和优化算法，其中损失函数都是用的是二元分类交叉熵函数。编译是用来配置模型学习过程的</span></span><br><span class="line">    g.compile(loss=<span class="string">'binary_crossentropy'</span>, optimizer=<span class="string">"SGD"</span>)</span><br><span class="line">    d_on_g.compile(loss=<span class="string">'binary_crossentropy'</span>, optimizer=g_optim)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#前一个架构在固定判别器的情况下训练了生成器，所以在训练判别器之前先要设定其为可训练。</span></span><br><span class="line">    d.trainable = <span class="keyword">True</span></span><br><span class="line">    d.compile(loss=<span class="string">'binary_crossentropy'</span>, optimizer=d_optim)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#下面在满足epoch条件下进行训练</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        print(<span class="string">"Epoch is"</span>, epoch)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#计算一个epoch所需要的迭代数量，即训练样本数除批量大小数的值取整；其中shape[0]就是读取矩阵第一维度的长度</span></span><br><span class="line">        print(<span class="string">"Number of batches"</span>, int(X_train.shape[<span class="number">0</span>]/BATCH_SIZE))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#在一个epoch内进行迭代训练</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(int(X_train.shape[<span class="number">0</span>]/BATCH_SIZE)):</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#随机生成的噪声服从均匀分布，且采样下界为-1、采样上界为1，输出BATCH_SIZE×100个样本；即抽取一个批量的随机样本</span></span><br><span class="line">            noise = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, size=(BATCH_SIZE, <span class="number">100</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#抽取一个批量的真实图片</span></span><br><span class="line">            image_batch = X_train[index*BATCH_SIZE:(index+<span class="number">1</span>)*BATCH_SIZE]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#生成的图片使用生成器对随机噪声进行推断；verbose为日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录</span></span><br><span class="line">            generated_images = g.predict(noise, verbose=<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#每经过100次迭代输出一张生成的图片</span></span><br><span class="line">            <span class="keyword">if</span> index % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">                image = combine_images(generated_images)</span><br><span class="line">                image = image*<span class="number">127.5</span>+<span class="number">127.5</span></span><br><span class="line">                Image.fromarray(image.astype(np.uint8)).save(</span><br><span class="line">                    <span class="string">"./GAN/"</span>+str(epoch)+<span class="string">"_"</span>+str(index)+<span class="string">".png"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#将真实的图片和生成的图片以多维数组的形式拼接在一起，真实图片在上，生成图片在下</span></span><br><span class="line">            X = np.concatenate((image_batch, generated_images))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#生成图片真假标签，即一个包含两倍批量大小的列表；前一个批量大小都是1，代表真实图片，后一个批量大小都是0，代表伪造图片</span></span><br><span class="line">            y = [<span class="number">1</span>] * BATCH_SIZE + [<span class="number">0</span>] * BATCH_SIZE</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#判别器的损失；在一个batch的数据上进行一次参数更新</span></span><br><span class="line">            d_loss = d.train_on_batch(X, y)</span><br><span class="line">            print(<span class="string">"batch %d d_loss : %f"</span> % (index, d_loss))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#随机生成的噪声服从均匀分布</span></span><br><span class="line">            noise = np.random.uniform(<span class="number">-1</span>, <span class="number">1</span>, (BATCH_SIZE, <span class="number">100</span>))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#固定判别器</span></span><br><span class="line">            d.trainable = <span class="keyword">False</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#计算生成器损失；在一个batch的数据上进行一次参数更新</span></span><br><span class="line">            g_loss = d_on_g.train_on_batch(noise, [<span class="number">1</span>] * BATCH_SIZE)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#令判别器可训练</span></span><br><span class="line">            d.trainable = <span class="keyword">True</span></span><br><span class="line">            print(<span class="string">"batch %d g_loss : %f"</span> % (index, g_loss))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#每100次迭代保存一次生成器和判别器的权重</span></span><br><span class="line">            <span class="keyword">if</span> index % <span class="number">100</span> == <span class="number">9</span>:</span><br><span class="line">                g.save_weights(<span class="string">'generator'</span>, <span class="keyword">True</span>)</span><br><span class="line">                d.save_weights(<span class="string">'discriminator'</span>, <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="TensorFlow-实现"><a href="#TensorFlow-实现" class="headerlink" title="TensorFlow 实现"></a>TensorFlow 实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#该函数将给出权重初始化的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable_init</span><span class="params">(size)</span>:</span></span><br><span class="line">    in_dim = size[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#计算随机生成变量所服从的正态分布标准差</span></span><br><span class="line">    w_stddev = <span class="number">1.</span> / tf.sqrt(in_dim / <span class="number">2.</span>)</span><br><span class="line">    <span class="keyword">return</span> tf.random_normal(shape=size, stddev=w_stddev)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义输入矩阵的占位符，输入层单元为784，None代表批量大小的占位，X代表输入的真实图片。占位符的数值类型为32位浮点型</span></span><br><span class="line">X = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, <span class="number">784</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义判别器的权重矩阵和偏置项向量，由此可知判别网络为三层全连接网络</span></span><br><span class="line">D_W1 = tf.Variable(variable_init([<span class="number">784</span>, <span class="number">128</span>]))</span><br><span class="line">D_b1 = tf.Variable(tf.zeros(shape=[<span class="number">128</span>]))</span><br><span class="line"></span><br><span class="line">D_W2 = tf.Variable(variable_init([<span class="number">128</span>, <span class="number">1</span>]))</span><br><span class="line">D_b2 = tf.Variable(tf.zeros(shape=[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">theta_D = [D_W1, D_W2, D_b1, D_b2]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义生成器的输入噪声为100维度的向量组，None根据批量大小确定</span></span><br><span class="line">Z = tf.placeholder(tf.float32, shape=[<span class="keyword">None</span>, <span class="number">100</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义生成器的权重与偏置项。输入层为100个神经元且接受随机噪声，</span></span><br><span class="line"><span class="comment">#输出层为784个神经元，并输出手写字体图片。生成网络根据原论文为三层全连接网络</span></span><br><span class="line">G_W1 = tf.Variable(variable_init([<span class="number">100</span>, <span class="number">128</span>]))</span><br><span class="line">G_b1 = tf.Variable(tf.zeros(shape=[<span class="number">128</span>]))</span><br><span class="line"></span><br><span class="line">G_W2 = tf.Variable(variable_init([<span class="number">128</span>, <span class="number">784</span>]))</span><br><span class="line">G_b2 = tf.Variable(tf.zeros(shape=[<span class="number">784</span>]))</span><br><span class="line"></span><br><span class="line">theta_G = [G_W1, G_W2, G_b1, G_b2]</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义一个可以生成m*n阶随机矩阵的函数，该矩阵的元素服从均匀分布，随机生成的z就为生成器的输入</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample_Z</span><span class="params">(m, n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.random.uniform(<span class="number">-1.</span>, <span class="number">1.</span>, size=[m, n])</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator</span><span class="params">(z)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#第一层先计算 y=z*G_W1+G-b1,然后投入激活函数计算G_h1=ReLU（y）,G_h1 为第二次层神经网络的输出激活值</span></span><br><span class="line">    G_h1 = tf.nn.relu(tf.matmul(z, G_W1) + G_b1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#以下两个语句计算第二层传播到第三层的激活结果，第三层的激活结果是含有784个元素的向量，该向量转化28×28就可以表示图像</span></span><br><span class="line">    G_log_prob = tf.matmul(G_h1, G_W2) + G_b2</span><br><span class="line">    G_prob = tf.nn.sigmoid(G_log_prob)</span><br><span class="line">    <span class="keyword">return</span> G_prob</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义判别器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discriminator</span><span class="params">(x)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计算D_h1=ReLU（x*D_W1+D_b1）,该层的输入为含784个元素的向量</span></span><br><span class="line">    D_h1 = tf.nn.relu(tf.matmul(x, D_W1) + D_b1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#计算第三层的输出结果。因为使用的是Sigmoid函数，则该输出结果是一个取值为[0,1]间的标量（见上述权重定义）</span></span><br><span class="line">    <span class="comment">#即判别输入的图像到底是真（=1）还是假（=0）</span></span><br><span class="line">    D_logit = tf.matmul(D_h1, D_W2) + D_b2</span><br><span class="line">    D_prob = tf.nn.sigmoid(D_logit)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#返回判别为真的概率和第三层的输入值，输出D_logit是为了将其输入tf.nn.sigmoid_cross_entropy_with_logits()以构建损失函数</span></span><br><span class="line">    <span class="keyword">return</span> D_prob, D_logit</span><br><span class="line"></span><br><span class="line"><span class="comment">#该函数用于输出生成图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot</span><span class="params">(samples)</span>:</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">    gs = gridspec.GridSpec(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">    gs.update(wspace=<span class="number">0.05</span>, hspace=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, sample <span class="keyword">in</span> enumerate(samples):</span><br><span class="line">        ax = plt.subplot(gs[i])</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br><span class="line">        ax.set_xticklabels([])</span><br><span class="line">        ax.set_yticklabels([])</span><br><span class="line">        ax.set_aspect(<span class="string">'equal'</span>)</span><br><span class="line">        plt.imshow(sample.reshape(<span class="number">28</span>, <span class="number">28</span>), cmap=<span class="string">'Greys_r'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入随机噪声z而输出生成样本</span></span><br><span class="line">G_sample = generator(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">#分别输入真实图片和生成的图片，并投入判别器以判断真伪</span></span><br><span class="line">D_real, D_logit_real = discriminator(X)</span><br><span class="line">D_fake, D_logit_fake = discriminator(G_sample)</span><br><span class="line"></span><br><span class="line"><span class="comment">#以下为原论文的判别器损失和生成器损失，但本实现并没有使用该损失函数</span></span><br><span class="line"><span class="comment"># D_loss = -tf.reduce_mean(tf.log(D_real) + tf.log(1. - D_fake))</span></span><br><span class="line"><span class="comment"># G_loss = -tf.reduce_mean(tf.log(D_fake))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们使用交叉熵作为判别器和生成器的损失函数，因为sigmoid_cross_entropy_with_logits内部会对预测输入执行Sigmoid函数，</span></span><br><span class="line"><span class="comment">#所以我们取判别器最后一层未投入激活函数的值，即D_h1*D_W2+D_b2。</span></span><br><span class="line"><span class="comment">#tf.ones_like(D_logit_real)创建维度和D_logit_real相等的全是1的标注，真实图片。</span></span><br><span class="line">D_loss_real = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=D_logit_real, labels=tf.ones_like(D_logit_real)))</span><br><span class="line">D_loss_fake = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=D_logit_fake, labels=tf.zeros_like(D_logit_fake)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#损失函数为两部分，即E[log(D(x))]+E[log(1-D(G(z)))]，将真的判别为假和将假的判别为真</span></span><br><span class="line">D_loss = D_loss_real + D_loss_fake</span><br><span class="line"></span><br><span class="line"><span class="comment">#同样使用交叉熵构建生成器损失函数</span></span><br><span class="line">G_loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=D_logit_fake, labels=tf.ones_like(D_logit_fake)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义判别器和生成器的优化方法为Adam算法，关键字var_list表明最小化损失函数所更新的权重矩阵</span></span><br><span class="line">D_solver = tf.train.AdamOptimizer().minimize(D_loss, var_list=theta_D)</span><br><span class="line">G_solver = tf.train.AdamOptimizer().minimize(G_loss, var_list=theta_G)</span><br><span class="line"></span><br><span class="line"><span class="comment">#选择训练的批量大小和随机生成噪声的维度</span></span><br><span class="line">mb_size = <span class="number">128</span></span><br><span class="line">Z_dim = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据集MNIST，并放在当前目录data文件夹下MNIST文件夹中，如果该地址没有数据，则下载数据至该文件夹</span></span><br><span class="line">mnist = input_data.read_data_sets(<span class="string">"./data/MNIST/"</span>, one_hot=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开一个会话运行计算图</span></span><br><span class="line">sess = tf.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化所有定义的变量</span></span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果当前目录下不存在out文件夹，则创建该文件夹</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'out/'</span>):</span><br><span class="line">    os.makedirs(<span class="string">'out/'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#初始化，并开始迭代训练，100W次</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> it <span class="keyword">in</span> range(<span class="number">20000</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#每2000次输出一张生成器生成的图片</span></span><br><span class="line">    <span class="keyword">if</span> it % <span class="number">2000</span> == <span class="number">0</span>:</span><br><span class="line">        samples = sess.run(G_sample, feed_dict=&#123;Z: sample_Z(<span class="number">16</span>, Z_dim)&#125;)</span><br><span class="line"></span><br><span class="line">        fig = plot(samples)</span><br><span class="line">        plt.savefig(<span class="string">'out/&#123;&#125;.png'</span>.format(str(i).zfill(<span class="number">3</span>)), bbox_inches=<span class="string">'tight'</span>)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        plt.close(fig)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#next_batch抽取下一个批量的图片，该方法返回一个矩阵，即shape=[mb_size，784]，每一行是一张图片，共批量大小行</span></span><br><span class="line">    X_mb, _ = mnist.train.next_batch(mb_size)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#投入数据并根据优化方法迭代一次，计算损失后返回损失值</span></span><br><span class="line">    _, D_loss_curr = sess.run([D_solver, D_loss], feed_dict=&#123;X: X_mb, Z: sample_Z(mb_size, Z_dim)&#125;)</span><br><span class="line">    _, G_loss_curr = sess.run([G_solver, G_loss], feed_dict=&#123;Z: sample_Z(mb_size, Z_dim)&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#每迭代2000次输出迭代数、生成器损失和判别器损失</span></span><br><span class="line">    <span class="keyword">if</span> it % <span class="number">2000</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'Iter: &#123;&#125;'</span>.format(it))</span><br><span class="line">        print(<span class="string">'D loss: &#123;:.4&#125;'</span>. format(D_loss_curr))</span><br><span class="line">        print(<span class="string">'G_loss: &#123;:.4&#125;'</span>.format(G_loss_curr))</span><br><span class="line">        print()</span><br></pre></td></tr></table></figure>
<p>参考文献：</p>
<ul>
<li>生成对抗网络原论文：<a href="https://arxiv.org/pdf/1406.2661.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1406.2661.pdf</a></li>
<li>Goodfellow NIPS 2016 Tutorial：<a href="https://arxiv.org/abs/1701.00160" target="_blank" rel="noopener">https://arxiv.org/abs/1701.00160</a></li>
<li>李弘毅MLDS17：<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLDS17.html" target="_blank" rel="noopener">http://speech.ee.ntu.edu.tw/~tlkagk/courses_MLDS17.html</a></li>
<li>Scott Rome GAN 推导：<a href="http://srome.github.io//An-Annotated-Proof-of-Generative-Adversarial-Networks-with-Implementation-Notes/" target="_blank" rel="noopener">http://srome.github.io//An-Annotated-Proof-of-Generative-Adversarial-Networks-with-Implementation-Notes/</a></li>
</ul>


<!-- Tags -->



<div class="tags">
    <a href="/tags/GAN/" class="button small">GAN</a>
</div>



<!-- Comments -->
<div>
    
    <hr />
    <h3>Kommentare:</h3>
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>



</div>



            </div>
        </div>

        <!-- Footer -->
<footer id="footer">
    <div class="inner">
        <section>
            <h2>About</h2>
            <div>
                If you are also interesting in Machine Learning, contact me with email：horatio.j.s.y@gmail.com.
            </div>
        </section>
        <section>
            <h2>Follow</h2>
            <ul class="icons">
                
                    <li><a href="https://twitter.com/Horatio_JSY" class="icon style2 fa-twitter" target="_blank" ><span class="label">Twitter</span></a></li>
                
                
                    <li><a href="https://www.facebook.com/horatio.jsy.3" class="icon style2 fa-facebook" target="_blank" ><span class="label">Facebook</span></a></li>
                
                
                
                
                    <li><a href="https://github.com/HoratioJSY" class="icon style2 fa-github" target="_blank" ><span class="label">GitHub</span></a></li>
                
                
                
                
                    <li><a href="https://500px.com/siyuan" class="icon style2 fa-500px" target="_blank" ><span class="label">500px</span></a></li>
                
                
                    <li><a href="horatio.j.s.y@gmail.com" class="icon style2 fa-envelope-o" target="_blank" ><span class="label">Email</span></a></li>
                
                
                    <li><a href="\#" class="icon style2 fa-rss" target="_blank" ><span class="label">RSS</span></a></li>
                
            </ul>
        </section>
        <ul class="copyright">
            <li>&copy; Siyuan All rights reserved</li>
            <li>Design: Horatio</li>
        </ul>
    </div>
</footer>
    </div>

    <!-- After footer scripts -->
    <script type="text/javascript"
color="139,129,80" opacity='0.4' zIndex="-2" count="40" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- skel -->
<script src="/js/skel.min.js"></script>

<!-- Custom Code -->
<script src="/js/util.js"></script>

<!--[if lte IE 8]>
<script src="/js/ie/respond.min.js"></script>
<![endif]-->

<!-- Custom Code -->
<script src="/js/main.js"></script>

<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->

<script type="text/javascript">
    var disqus_shortname = 'Autum';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax --><!-- hexo-inject:begin --><!-- hexo-inject:end -->

<!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
</body>

</html>